"""
Purpose: to generate an image and a header file from a list of marker locations and sizes.
This will help garuntee these two resources are consistent and allow for more rapid prototyping.

The file is a list of line separated markers or marker grids.

But the first line is of the format (must be the first line!)
board-width board-height resolution

all measurements are cm except resolution which is dots-per-cm

A grid line has the format where x and y are the coordinates of the top left of the group:
G x-count y-count | size padding x y
An example if four markers as a 2x2 at location (15, 30) seperated by 5 units and size of 10 with 2 being padding (on all sides)
G 2 2 | 10 2 15 30

A single marker has the following format(same coordinate scheme as groups)
S size padding x y
an example of a marker at (2, 5) and size 3 with 1 being padding (on all sides so the marker is actually 3-.5*2 = 2)
S 3 .5 2 5

comments start with '# ' (the space is necessary!)

everything must be separated by a space or tab
units are in centimeters
"""

import io
import cv2
import cv2.aruco as aruco
import numpy

# returns a list of ints from the list of strings
# it returns None on any number that failed to parse as an int
def list_str_to_float(strings):
    def helper(x):
        try:
            return float(x)
        except ValueError:
            return None

    return [helper(string) for string in strings]


class RegenerateMarkers:
    def __write_marker(self, size, padding, x, y):
        # offset padding and shrink so only size, x, y are needed
        x += padding
        y += padding
        size -= padding*2

        # get meter equivilents of the cm measurements
        [meter_x, meter_y, meter_size] = [w * .01 for w in [x, y, size]]

        # move board half-width, from centimeters to meters
        meter_x -= self.board_width / 100 / 2

        # write our the source for this line
        self.header_out.write('\tmarkerPoints = \n')
        self.header_out.write('\t{\n')
        self.header_out.write('\tcv::Point3f(' + str(meter_x) + ', ' + str(meter_y) + ', 0),\n')
        self.header_out.write('\tcv::Point3f(' + str(meter_x+meter_size) + ', ' + str(meter_y) + ', 0),\n')
        self.header_out.write('\tcv::Point3f(' + str(meter_x+meter_size) + ', ' + str(meter_y+meter_size) + ', 0),\n')
        self.header_out.write('\tcv::Point3f(' + str(meter_x) + ', ' + str(meter_y+meter_size) + ', 0)\n')
        self.header_out.write('\t};\n')
        self.header_out.write('\tboardCorners.push_back(markerPoints);\n')
        self.header_out.write('\tboardIds.push_back(' + str(self.current_id) + ');\n\n')

        # get pixel equivilents of the cm measurements
        [pixel_x, pixel_y, pixel_size] = [int(w * self.pixels_per_cm) for w in [x, y, size]]

        # create the aruco marker image
        marker_img = aruco.drawMarker(self.aruco_dict, self.current_id, pixel_size)
        self.current_id += 1

        # copy to the larger image at the appropriate location (by creating an ROI out of the big image to copy to)
        self.image_out[pixel_y:pixel_y+pixel_size, pixel_x:pixel_x+pixel_size] = marker_img
        
    def __process_single(self, tokens, idx):
        if(len(tokens) != 4):
            print('ERROR, expected 4 values for a single marker on line ' + str(idx))
            return
        converted = list_str_to_float(tokens)
    
        # check if any number failed to convert
        if(not all([num != None for num in converted])):
            print('ERROR, failed to translate token to number on line ' + str(idx))
            return
    
        size = converted[0]
        padding = converted[1]
        x = converted[2]
        y = converted[3]
        self.__write_marker(size, padding, x, y)
    
    def __process_group(self, tokens, idx):
        if(len(tokens) != 7):
            print('ERROR, expected 7 values for a group marker on line ' + str(idx))
            return
        if(tokens[2] != '|'):
            print('ERROR, expected a \'|\' or it was in the wrong position on line ' + str(idx))
            return
    
        # get numbers without the '|' separator
        converted = list_str_to_float(tokens[0:2] + tokens[3:])
    
        # check if any number failed to convert
        if(not all([num != None for num in converted])):
            print('ERROR, failed to translate token to number on line ' + str(idx))
            return
    
        x_count = int(converted[0])
        y_count = int(converted[1])
    
        size = converted[2]
        padding = converted[3]
        x = converted[4]
        for x_i in range(x_count):
            y = converted[5]
            for y_i in range(y_count):
                self.__write_marker(size, padding, x, y)
                y += size
            x += size

    def __run(self):
        self.header_out.write('// do not edit! This is an autogenerated file (see regenerate_markers.py in the aruco folder)\n')
        self.header_out.write('void setBoardData(std::vector<std::vector<cv::Point3f> > &boardCorners, std::vector<int> &boardIds)\n')
        self.header_out.write('{\n')
        self.header_out.write('\tstd::vector<cv::Point3f> markerPoints;\n')
        
        for idx, line in enumerate(self.input_file):
            # clean input
            line = line.strip().upper()

            if(idx == 0):
                values = list_str_to_float(line.split())
                if(len(values) != 3):
                    print('ERROR, expeced width, height and resolution on first line')
                self.board_width = values[0]
                self.board_height = values[1]
                self.pixels_per_cm = values[2]/2.54 # from dpi to dots per cm

                res_x = int(self.board_width*self.pixels_per_cm)
                res_y = int(self.board_height*self.pixels_per_cm)
                self.image_out = numpy.ones((res_y, res_x),numpy.uint8)*255
                continue
        
            # skip empty lines
            if(line == ''):
                continue
        
            tokens = line.split()
        
            if(tokens[0] == 'S'):
                self.__process_single(tokens[1:], idx)
            elif(tokens[0] == 'G'):
                self.__process_group(tokens[1:], idx)
            elif(tokens[0] == '#'):
                pass
            else:
                print('ERROR, unexpected syntax error on line ' + str(idx) + '. expected S or G, but got ' + tokens[0])
        
        self.header_out.write('}\n')
        cv2.imwrite('aruco.jpg', self.image_out)

    def __init__(self):
        self.input_file = open('board.data', 'r')
        self.header_out = open('src/generatedMarker.h', 'w')

        self.aruco_dict = aruco.Dictionary_get(aruco.DICT_5X5_250)
        self.current_id = 1

        self.__run()


# the __init__ of this class is essentially main
RegenerateMarkers()
